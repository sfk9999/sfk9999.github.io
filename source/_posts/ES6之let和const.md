---
title: ES6之let和const
date: 2017-9-05 16:58:08
toc: true
tags:
    - JavaScript
    - ES6
---

ES6提供了let和const两种新的变量声明方式，使得在JS中变量的声明更像java那样。
<!--more-->


#### let和const命令
##### 1.let命令
###### 1.1.基本用法
- let所声明的变量，只在let命令所在的代码块内有效
- var
    ```
    var a = [];
    for (var i = 0; i < 10; i++) {
      a[i] = function () {
        console.log(i);
      };
    }
    a[6](); // 10
    //变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。
    ```
- let
    ```
    var a = [];
    for (let i = 0; i < 10; i++) {
      a[i] = function () {
        console.log(i);
      };
    }
    a[6](); // 6
    //变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量
    ```
- for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。

###### 1.2 不存在变量提升
let所声明的变量一定要在声明之后使用

###### 1.3 暂时性死区
- 只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。
- 如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。

###### 1.4 不允许重复声明
let不允许在相同作用域内，重复声明同一个变量

##### 2 块级作用域
###### 2.1 为什么需要块级作用域
- 没有块级作用域的场景
    - 第一种场景，内层变量可能会覆盖外层变量
    - 第二种场景，用来计数的循环变量泄露为全局变量。

###### 2.2 ES6的块级作用域 let
- let实际上为js新增了块级作用域
- 外层作用域无法读取内层作用域的变量
- 内层作用域可以定义外层作用域的同名变量

###### 2.3 块级作用域与函数声明
- ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。
    ```
    //这种情况在es5中是非法的
    if (true) {
      function f() {}
    }
    ```
- ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。
- **但是，应该避免在块级作用域内声明函数**
- 如果确实需要，也应该写成函数表达式，而不是函数声明语句。
    ```
    //函数声明
    {
        let a = 'secret';
        function f(){
            return a;
        }
    }
    
    //函数表达式
    {
        let a ='secret',
        let f = function(){
            return a;
        };
    }
    ```
- ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。

##### 3 const命令
###### 3.1 基本用法
- const声明一个只读的常量。一旦声明，常量的值就不能改变。
- 一旦声明变量，就必须立即初始化。
- 作用域：只在声明所在的块级作用域内有效。

###### 3.2 本质
- const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。
- 在对象中，不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。
- 如果真的想将对象冻结，应该使用Object.freeze方法。

##### 4 顶层对象的属性
- 顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。
- ES5 之中，顶层对象的属性与全局变量是等价的。
- 一方面var命令和function命令声明的全局变量，依旧是顶层对象的属性
- 另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。
