---
title: Web安全
date: 2017-12-06 09:21:38
toc: true
tags:
    - Web安全
---
本文主要介绍了7种常见的Web安全的攻击以及防御，作为一个Web开发者应该去了解下
<!--more-->

#### 一、XSS(跨站脚本攻击)
##### 1.1 XSS
- XSS 攻击，全称是“跨站点脚本攻击”
- XSS是一种经常出现在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其他用户使用的页面中。
- XSS是针对Web站点的客户隐私的攻击，当客户详细信息失窃或受控时可能引发彻底的安全威胁
- XSS 攻击同时涉及三个群体：黑客、客户端和 Web 站点。
- XSS 攻击的**目的**是盗走客户端 cookies，或者任何可以用于在 Web 站点确定客户身份的其他敏感信息。手边有了合法用户的标记，黑客可以继续扮演用户与站点交互，从而冒充用户。 
- 跨站脚本攻击有两种攻击形式： 
    1. 反射型跨站脚本攻击 
        - 攻击者会通过社会工程学手段，发送一个URL连接给用户打开，在用户打开页面的同时，浏览器会执行页面中嵌入的恶意脚本。 
    2. 存储型跨站脚本攻击 
        - 攻击者利用web应用程序提供的录入或修改数据功能，将数据存储到服务器或用户cookie中，当其他用户浏览展示该数据的页面时，浏览器会执行页面中嵌入的恶意脚本。所有浏览者都会受到攻击。
    3. DOM跨站攻击 
        - 由于html页面中，定义了一段JS，根据用户的输入，显示一段html代码，攻击者可以在输入时，插入一段恶意脚本，最终展示时，会执行恶意脚本。 
    4. DOM跨站和以上两个跨站攻击的差别是，DOM跨站是纯页面脚本的输出，只有规范使用javascript，才可以防御。

##### 1.2 原理
- 攻击者可以在添加产品时插入恶意脚本；攻击者发布产品后，等待用户浏览产品列表页面；就会执行攻击者写的 inbreak.net/a.js 恶意脚本
- 功能是获取当前浏览者的cookie，并发送到a.php，用户的cookie已经就会到攻击者的服务器上。攻击者利用浏览器插件，将自己的cookie替换成刚刚获取的用户的cookie，就可以狸猫换太子的冒充用户了。

##### 1.3 防御
- 最基本的防御就是对用户的输入在后台进行转义(因为直接保存输入的字符串再输出就会运行JS了)

#### 二、CSRF跨站请求伪造攻击
##### 2.1 原理
- 攻击者在用户浏览网页时，利用页面元素（例如img的src），强迫受害者的浏览器向Web应用程序发送一个改变用户信息的请求。 
- CSRF攻击可以从站外和站内发起。 
    - 从站内发起CSRF攻击，需要利用网站本身的业务，比如“自定义头像”功能，恶意用户指定自己的头像URL是一个修改用户信息的链接，当其他已登录用户浏览恶意用户头像时，会自动向这个链接发送修改信息请求。 
    - 从站外发送请求，则需要恶意用户在自己的服务器上，放一个自动提交修改个人信息的htm页面，并把页面地址发给受害者用户，受害者用户打开时，会发起一个请求。 
- 如果恶意用户能够知道网站管理后台某项功能的URL，就可以直接攻击管理员，强迫管理员执行恶意用户定义的操作。

##### 2.2 防御
- 必须遵循以下三步
    1. 在用户登录时，设置一个随机的TOKEN也就是令牌，同时种植在用户的cookie中，当用户浏览器关闭、或用户再次登录时，清除TOKEN：
    2. 在表单中生成一个隐藏域，它的值就是cookie中随机TOKEN：
    3. 表单被提交后，就可以判断表单中的TOKEN和用户cookie中的TOKEN是否一致，如果不一致或没有这个值，就是CSRF攻击：

#### 三、SQL注入
##### 3.1 原理
- SQL注入攻击是通过非友好的SQL语句拼接来获取该用户没有权限访问的数据。 
- 当应用程序将用户输入的内容，拼接到SQL语句中，一起提交给数据库执行时，就会产生SQL注入威胁。 
- 由于用户的输入，也是SQL语句的一部分，所以攻击者可以利用这部分可以控制的内容，注入自己定义的语句，改变SQL语句执行逻辑，让数据库执行任意自己需要的指令。

##### 3.2 防御
- 在后台可以通过预处理执行SQL语句，并对所有传入SQL语句中的变量做绑定

#### 四、XML注入
##### 4.1 原理
- XML注入攻击，和SQL注入的原理一样，都是攻击者输入恶意的代码来执行自身权限以外的功能。
- XML是存储数据的一种方式，如果在修改或者查询时，没有做转义，直接输入或输出数据，都将导致XML注入漏洞。
- 攻击者可以修改XML数据格式，增加新的XML节点，对数据处理流程产生影响。

##### 4.2 防御
对关键字符串进行转义
```
& --> &amp;
 < --> &lt;
 > --> &gt;
 " --> &quot;
 ' --> &#39; 
```

#### 五、文件操作
分为文件上传攻击和文件下载攻击。
##### 5.1 文件上传攻击
Web应用程序在处理用户上传的文件时，没有判断文件的拓展名是否在允许的范围内，就把文件保存在服务器上，导致恶意用户可以上传任意文件，甚至上传木马到Web服务器上，直接控制服务器。
###### 5.1.1 防御
- 想要防止文件上传攻击，需要做到以下几点： 
    1. 检测上传文件扩展名白名单，不属于白名单，不允许上传。 
    2. 上传文件的目录必须是http请求无法直接访问到的，如果需要访问，必须上传到其他域名下，并设置该目录不解析php等脚本语言。 
    3. 上传文件保存的文件名和目录名由系统根据时间生成，不允许用户自定义
    4. 图片上传，要通过处理（压缩图、水印），无异常后才能保存到服务器。

##### 5.2 文件下载攻击
- 处理用户请求下载文件时，如果允许用户提交任意文件目录，并把服务器上对应的文件直接发送给用户，将造成任意文件下载攻击。如果让用户提交文件目录地址，就把目录下的文件列表发送给用户，会造成目录遍历安全威胁。 
- 攻击者可以下载服务器上的敏感文件，比如数据库链接配置文件、网站源代码等。

###### 5.2.1 防御
- 要防止文件下载攻击，需要做到以下几点： 
    1. 将要下载的文件地址保存在数据库中，让用户提交文件对应ID下载文件。 
    2. 文件放在Web无法直接访问的目录 
    3. 下载文件之前做权限判断。

#### 六、权限攻击
##### 6.1 水平权限攻击
水平权限攻击，也叫作访问控制攻击。Web应用程序接收到用户请求，修改某条数据时，没有判断数据的所属人，或者在判断数据所属人时从用户提交的表单参数中获取了userid。导致攻击者可以自行修改userid修改不属于自己的数据。所有的更新语句操作，都可能产生这个漏洞。
###### 6.1.1 防御
从用户的加密认证cookie中获取当前用户id，并且在执行的sql语句中加入当前用户id作为条件语句。由于cookie是加密的，所以攻击者无法修改加密信息。

##### 6.2 垂直权限攻击
垂直权限攻击又叫做权限提升攻击。其原理是由于Web应用没有做权限控制，或仅仅在菜单上做了权限控制，导致恶意用户只要猜测其他管理页面的URL，就可以访问或控制其他角色拥有的数据或页面，达到权限提升的目的。
###### 6.2.1 防御
在每个页面的加载之前进行权限验证即可。一个普通的权限系统，菜单是通过数据库中对应权限和角色来进行字符串拼接形成的，而不是静态的通过在页面上进行权限判断决定的。

#### 七、（前端方法）Cookie管理
对应之前的XSS攻击(原理是利用脚本读取用户Cookie从而造成用户信息泄露)
##### 7.1 HttpOnly
该属性值的作用就是防止Cookie值被页面脚本读取。一个没有设置HttpOnly的Cookie
```
setcookie("name","lf");

//添加HttpOnly属性为true
setcookie('age','23',NULL,NULL,NULL,NULL,TRUE);
```
切记HttpOnly属性只是增加了攻击者的难度，不能达到完全防御XSS攻击。
##### 7.2 Secure
给Cookie设置Secure属性时，只有在https协议下访问的时候，浏览器才会发送该Cookie。
```
//在之前添加HttpOnly属性为true的基础上
setcookie('age','23',NULL,NULL,NULL,NULL,TRUE);

//添加Secure属性为true
setcookie('gf','tyq',Null,Null,Null,TRUE,Null);
```
##### 7.3 有效期
- 添加两个时间
    - 即使在一直活动也要失效的时间
    - 长时间不活动的失效的时间
```
// 判断会员的cookie是否过期
if (isLogin) {
    String timeStampStr = (String) map.get(UserAuthenticationContext.TIMESTAMP);
    long loginTime = 0;
    try {
        loginTime = Long.parseLong(timeStampStr);
    } catch (NumberFormatException e) {
        if (logger.isInfoEnabled()) {
            logger.info(" loginId: " + usr.getLoginId() + " timestamp has exception " + timeStampStr);
        }
    }
    long now = System.currentTimeMillis() / 1000;
    if (now - loginTime > UserAuthenticationContext.COOKIE_VALIDITY) {
        usr.setAuthenticated(false, true);
        if (logger.isInfoEnabled()) {
            logger.info("loginId: " + usr.getLoginId() + " loginTime: " + loginTime + " nowTime: " + now);
        }
    }
}
```